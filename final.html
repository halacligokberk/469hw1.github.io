<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Final - My Blog</title>
  <style>
        code {
      background: #f4f4f4;
      color: #c7254e;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 95%;
    }
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }
    header {
      background-color: #333;
      color: #fff;
      padding: 1rem 0;
      text-align: center;
    }
    header nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    header nav ul li {
      display: inline;
      margin: 0 10px;
    }
    header nav ul li a {
      color: #fff;
      text-decoration: none;
    }
    .container {
      width: 90%;
      max-width: 800px;
      margin: 20px auto;
      padding: 0 10px;
      padding-bottom: 80px;
    }
    article {
      background-color: #fff;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    footer {
      position: relative;
      background-color: #333;
      color: #fff;
      text-align: center;
      padding: 1rem 0;
      position: fixed;
      width: 100%;
      bottom: 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>Gökberk's Graphics Blog</h1>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="#about">About</a></li>
        <li><a href="hw2.html">HW2</a></li>
        <li><a href="hw3.html">HW3</a></li>
        <li><a href="final.html">Final</a></li>
      </ul>
    </nav>
  </header>
  
  <div class="container">
    <article>
      <h2>CENG 469 Final Project Blog</h2>
      <p>
        
        Eren Gökberk Halaçlı - Emre Çam
        
            <h3>Project Overview</h3>

        In this project we rendered a nature scene that contains a Sakura tree
        shedding its flowers, and a lake that captures the reflection of the sakura
        tree and the environment. Let’s go over each part one by one.

        <br>

            <h3>Sakura Tree & Falling Flowers</h3>

        
                    We used royalty-free tree and flower models and rendered them directly.
        For simulating the falling flowers we utilized the GPU as much as we can. We
        used Shader Storage Buffer Objects(SSBOs) to store the per flower state. We
        used separate buffers for state data such as the position, rotation, movement and
        randomization which we tell in more detail. In every rendering pass those
        buffers are updated by a compute buffer. This greatly increases the
        performance of our application by taking a burden from the CPU. Now lets talk
        about the leaf movement and our buffers.
                
        <br>

        Each flower/leaf does two main movements, they rotate around
        themselves and follow a helix-like shape while falling. To create a helix, they
        make a constant velocity movement in the y-axis with some perturbations.
        Whereas in the x-axis they follow a parametrized sinus curve that can be
        formulated as follows:

                <br>
        
                <pre><code class="language-cpp">
        
                X_new = X_start + C*sin(omega*t + P) + noise

                </code></pre>

                <br>
    
            The constant C is the circumference of the helix, t is the frequency it
        controls how fast the flowers are spinning and P is the Phase movement
        constant. We also add a scalar Perlin noise component to increase
        randomness.

        <br>

        To simulate the self-centered rotation, we use the following formula:
            
            <br>
            
            <pre><code class="language-cpp">

            R_new = R_start + 0.005 + noise (mod 360)
                
            </code></pre>


            <br>
        We use Euclid angles since GLSL doesn’t have any built-in quaternion support.
        We basically initialize the rotation of leaves with random numbers in their
        spawn points and rotate them repeatedly in each axis by a random amount.
        The relationship between the buffers and the aforementioned numbers are as
        follows:

            <br>

            <ul>
            <li>Position SSBO: Stores the current position of the leaf.</li>
            <li>Rotation SSBO: Stores the current self-centered rotation state of the leaf.</li>
            <li>Randomizer SSBO: Stores the randomizer constants for the helix movement.</li>
            </ul>

            <br>

                Now we are all set for rendering. Since we are going to render flowers in
            masses, we need an efficient way other than rendering the flowers in a for
            loop. Instanced rendering is the way-to-go for this case, it also very easy to
            use ! We just replace glDrawElements call with glDrawElementsInstanced and
            provide the number of instances to render as an additional argument. So, what
            is the difference between these two? In glDrawElements, CPU tells the GPU to
            draw only once and drawing repeatedly in a for loop comes with a CPU-GPU
            communication overhead. In instanced drawing CPU tells the GPU to draw
            multiple times and this greatly reduces the overhead. Instanced rendering also
            provides a built-in gl_InstanceID argument to the vertex shader. This
            argument stores the id number (starting from zero) of the argument that is
            currently rendering in the shader. With this id we can select the related
            information from the SSBOs during the rendering process.

            <br>
            <br>

            Now we can simulate just a group of flowers falling from the tree.
            To make it a repeated motion we need to spawn new flowers regularly. We can
            do this by extending the SSBOs regularly. However this comes with a
            downside, extending and SSBO is a really expensive operation because it
            requires us to allocate more space in the GPU, create new data in the CPU
            and copy it to GPU. This causes the program to lag during the new flower
            spawns. Here is a video that shows it:
                        <br>


          <video width="100%" controls>
            <source src="flower_flicker.mkv" type="video/mkv">
          </video>


                        <br>

            After giving it some thought, we decided to preallocate a certain amount of
            SSBO space (and never allocate again) during the program initialization and
            increase the number of flowers we are rendering regularly. This solves the
            performance issue but puts a limit on how many flowers can fall from the tree.
            We can have a limit of 100.000 without any problems so I think it is okay since
            most trees don’t have that many flowers.

            <br>

            [Düzgün halinin videosu]

            <br>

            <h3>Water with Reflections</h3>

                        <br>


            Our project also captures a lake where you can see the reflection
                of the environment, distorted view of the sakura tree and, there are also flowers floating on it.

                            <br>

        [A closer video of the pond]

                    <br>

        Let’s talk about the technical parts of the pond. First of all, there is no
        pond. What you see in the screen is a waving mirror (like the ones you see in
        amusement parks).

                <br>

                    <figure>
              <img src="image.png" alt="image credits: https://decorativeantiques.uk/products/fairground-distortion-
mirror?variant=41598986485826" style="width: 80%; height: auto;">
              <figcaption> image credits: https://decorativeantiques.uk/products/fairground-distortion-
mirror?variant=41598986485826 </figcaption>
    
            </figure>

            <br>

            The funny thing is the mirror is not actually waving, the waving effect is
done in shader by creating distorted normals. And the mirror is … is a mirror,
no tricks in there :)

            <br>
        Now lets examine the technical parts basic to simple.

            <br>

            <h4>The Mirror</h4>

                        <br>


                    There are numerous ways to create reflections in graphics, we didn’t
        want to use ray-tracing to make the program lighter. Most of the methods
        outside ray-tracing are some version of using a “reflected” camera across the
        mirror surface and using the renders of that camera as the reflections.
        There are multiple ways to implement this approach, one way is to
        literally reflect the main camera by keeping a second camera which has the
        matrices of a reflected camera.

                    <br>

We tried this first but we encountered several issues:

            <br>

            <ul>
        <li> If we move the actual camera(POV of the user), we need to apply the correct
        version of that transformation to the mirrored camera. It was complicated for
        us to find those correct versions, we ended up having the tree and its
        reflection going to different directions when we move the camera.
        </li>
        
        <li> The other issue is the left and right of the mirrored and original cameras are
        inverted because of that, the reflection was not right to begin with
        </li>
        </ul>
                    <br>

        [Bozuk halinden görüntüler]

                    <br>

        Because of these reasons we changed our reflection method to
        something simpler. Instead of reflecting the camera, we decided to reflect the
        objects with a modeling matrix change: a reflection matrix.

                    <br>


            <pre><code class="language-cpp">
    
            reflection[0][0] = 1.0f - 2.0f * n.x * n.x;
            reflection[1][1] = 1.0f - 2.0f * n.y * n.y;
            reflection[2][2] = 1.0f - 2.0f * n.z * n.z;
            reflection[3][3] = 1.0f;
            
            reflection[0][1] = -2.0f * n.x * n.y;
            reflection[0][2] = -2.0f * n.x * n.z;
            reflection[1][2] = -2.0f * n.y * n.z;

            reflection[1][0] = -2.0f * n.x * n.y;;
            reflection[2][0] = -2.0f * n.x * n.z;;
            reflection[2][1] = -2.0f * n.y * n.z;; 
            
            reflection[0][3] = -2.0f * n.x * d;
            reflection[1][3] = -2.0f * n.y * d;
            reflection[2][3] = -2.0f * n.z * d;
            
            reflection[3][0] = 0.0f;
            reflection[3][1] = 0.0f;
            reflection[3][2] = 0.0f;
            
            </code></pre>

                    <br>

        This formula is the homogenous-3D version of 2D reflection.





      </p>
    </article>
  </div>
  
  <footer>
    <p>&copy; 2025, Eren Gökberk Halaçlı</p>
    <p class="last-edit-date"><em>Last edited: <span id="lastEdit"></span></em></p>
  </footer>
</body>
</html>
<script>
  document.getElementById('lastEdit').textContent = 
    new Date(document.lastModified).toLocaleString();
</script>
<style>
  .last-edit-date {
    color: #888;
    font-size: 0.95em;
    margin-top: -10px;
    margin-bottom: 15px;
  }
</style>
